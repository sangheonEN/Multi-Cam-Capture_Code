[쮸리아빠] [오전 9:04] import datetime

import cv2
import threading
import os

base_path = os.path.dirname(os.path.abspath("__file__")) +'\\' #base path 경로 마지막 수정

fourcc = cv2.VideoWriter_fourcc(*'XVID')
record_flag = False

class camThread(threading.Thread):
    def __init__(self, previewName, camID):
        threading.Thread.__init__(self)
        self.previewName = previewName
        self.camID = camID

    def run(self):
        print(f"Starting {self.previewName}")
        camPreview(self.previewName, self.camI
[쮸리아빠] [오전 9:04] ---변경한내용---
1. base_path 끝에 '\\' 추가

2. previewName+base_path+str(now)+".avi" 경로 오류 수정(base_path가 앞에)

3. 레코딩 스레드 함수내 record(전역변수) global 선언

4. r키 입력시 record 변수만 true로 바꾸고, videowriter 초기화 로직 추가

5. waitkey(20) → waitkey(1)로 변경
  멀티스레딩이고, 카메라 3대면 속도가 느려서 바꿔봤습니다. PC 성능에 맞게 설정하면 됩니다.

이렇게 바꾸면 3개 동시 녹화 됩니다..
[가나다] [오전 9:57] 헉 제가 이제 확인했네요 바로 적용해보겠습니다 잠시만요
[가나다] [오전 9:57] waitkey(20) 는 속도랑 혹시 어떤 연관성이 있을까요??
[가나다] [오전 9:59] 어제 3번까지는 저도 오류 보고 수정해놓은 상태고 4, 5 적용해볼게요!
[가나다] [오전 10:00] 코드가 짤렸는데 혹시 다시 좀 보내주실 수 있나요?
[쮸리아빠] [오전 10:00] 20ms 동안 키보드 입력을 기다린다는건데, 카메라 3대 및 녹화면 이미 처리시간을 많이잡아먹어서 1로 바꾸는게 더 빠르게 처리됩니다.
[가나다] [오전 10:01] 감사합니다!
[쮸리아빠] [오전 10:01] 파일: test.txt
[가나다] [오전 10:02] 우선 안보고 제가한번 짜볼게요
[가나다] [오전 10:27] 쮸리아빠님, 혹시 저 아이디어의 인사이트가 있을까요?? 어떤 로직에 의해서 저 아이디어가 떠오르셨나요??;;

현 상황은 비디오 3개의 인스턴스가 병렬처리되어 수행된다고 생각되는데요. 근데 여기서 def run이 수행되면서 camPreview 메서드 내에서는 병렬처리라서 3cam 동시에 수행된다고 생각하면 될까요?? 컴퓨터 메모리 상에서 보면 3가지 공간에서 병렬적으로 Cam1, Cam2, Cam3의 camPreview가 수행된다고 생각하면 될까요??

기존의 제 코드가 안되는 이유가 궁금합니다
[쮸리아빠] [오전 10:43] 삭제된 메시지입니다.
[쮸리아빠] [오전 10:44] imshow/waitkey는 하나의 창(window)에 대한 입력을 받는데,
r 키를 눌렀을때 병렬 실행되는 3개의 스레드에서 동시에 녹화를 하기위해

전역으로 record 변수를 선언한 걸로 이해했습니다.

그런데 기존코드는 r키 입력시 elif key == 114에 '한번만' 진입하게되고

최초에 녹화동영상 파일을 생성하는 cv2.VideoWriter 또한 한번만 실행되기때문에
나머지 2개 영상은 녹화되지 않겠죠.
3개의 동영상이 녹화되려면 각각 cv2.VideoWriter를 별도로 호출해야합니다.

그래서 R키에 대한 처리는 record=True 만 부여하고,

def camPreview의 반복문 안에서는
record=True인데 videowriter 객체가 초기화되지 않은 경우 초기화하는 로직을 추가했습니다.
[쮸리아빠] [오전 10:44] 그리고, 원래코드에서 video가 elif key == 114: 조건 아래에 local로 선언되면,
video.release() / video.write(frame) 등 다른 위치에서는 모르기때문에
반복문진입 전에 video = -1로 초기화 해줬습니다.
[가나다] [오전 10:45] 쮸리아버님 디버그 해보니까 previewName에 하나씩 Cam이 들어오고 while 문에서 반복하길래 Resume program해보니 디버그가 루프문을 벗어나서 다음 cam으로 다시 메서드가 수행되는데 이건 무슨 현상인가요;;??

첫번째 캠이 어디서 작동을하고 있는건가요??;;
[가나다] [오전 10:48] video = -1 이게 뭐를 초기화 하는거죠??
[들보] [오전 10:48] 혹시
[들보] [오전 10:49] 멀티스레드 다뤄보셨나요
[가나다] [오전 10:49] 처음입니다
[들보] [오전 10:49] 음...
[가나다] [오전 10:49] 어디서부터 공부를해야할까요??
[들보] [오전 10:49] 스레드 개념부터 이해하셔야 좀 더 편하게 이해하실거 같은데
[가나다] [오전 10:49] 그 파이썬 내장함수 스레드 말씀하시는거죠?
[가나다] [오전 10:49] 이게 보니까 인스턴스가 호출되는게 스텍 형식이더라구요
[가나다] [오전 10:50] 사진
[가나다] [오전 10:50] 이렇게 코드를 짯는데 Cam3번부터 호출되더라구요
[가나다] [오전 10:50] 들보님 이게 그럼 저 캠 인스턴스들이 반복하는 작업을 스레드에 담아서 계속 수행시키는 역할을 하는게 스레드 클래스 인가요???
[들보] [오전 10:51] 제가 교육중이라 좀 디테일하게 보질 못하고 있습니다
[가나다] [오전 10:51] 사진
[가나다] [오전 10:52] Cam마다 Loop를 돌면서 작업이 수행되잖아요. 이게 3개의 Cam 인스턴스를 스레드로 실행하면 3개의 스레드가 생성되고 각각에 인스턴스가 부여되어서 저 loop가 계속 수행되는 프로세스인거죠??
[봉구] [오전 10:58] 디버깅해보셔도되것네용 ㅋ
[가나다] [오전 10:58] 디버그해보니까 첫번째 cam loop만 계속 돌아서;;
[가나다] [오전 10:58] 두번째로 넘어가는 구간이 언제인지 모르겠습니다;; 코드 상엔 그런게 없으니
[들보] [오전 10:59] 파이참인가요
[들보] [오전 10:59] 멀티스레드 디버깅은 테크닉이 좀 필요해서
[가나다] [오전 10:59] 넵 파이참입니다!
[들보] [오전 10:59] 브레이크 걸 때 스레드 아이디를 조건으로 넣어주면 좀 편하긴 한데
[들보] [오전 11:00] 이게 지금 교육중이라 원격 봐드리기도 애매하네요
[가나다] [오전 11:00] 잠시만요 제가 일단 구글링한번해볼게요
[가나다] [오전 11:00] 일단 차근차근 스레드부터 공부하고 올게요
[가나다] [오전 11:00] 교육하시고 계십시오!
[쮸리아빠] [오전 11:04] 사진
[쮸리아빠] [오전 11:04] 요렇게 스레드 함수가 최초 호출되는 순서는 항상 123인데
[쮸리아빠] [오전 11:05] 루프에 진입하는 순서는 다를 수 있고 그게 언제인지 모르는 이유는

[쮸리아빠] [오전 11:05] cam = cv2.VideoCapture(camID)
카메라 디바이스를 비디오 캡쳐로 불러올때 카메라 장비, 해상도 등에 따라서 속도가 제각각이라서 그래요
[쮸리아빠] [오전 11:06] 병렬로 실행할때 4k 카메라를 제일먼저 붙여도, 마지막에 붙인 HD 카메라가 먼저 붙어서 루프에 들어갈겁니다
[가나다] [오전 11:06] 제가 궁금한게 이게 3개의 스레드가 계속 ram에 올라가 스레드라는 3개의 저장공간을 만들어서 거기에 인스턴스의 메서드를 저장하여 loop문이 계속 수행되는 형식인가요?
[쮸리아빠] [오전 11:10] ram과 저장공간도 내부적으로 만들어지고 말씀하신대로 수행되는 형식이다.라고봐도 될것같긴한데
보통 스레드하면 메모리 보다는 cpu와 프로세스단위를 스레드 단위로 나누는 설명을 주로하죠.
(사실 저도 스레드는 잘모릅니다
[가나다] [오전 11:11] r을 누르면 record flag가 on되어 다음 loop에서 video 객체가 생성되면서 녹화가 진행되는거지요??
[가나다] [오전 11:12] 단순히 r과 e는 flag를 on-off 하는 역할이고 video 객체는 저장되면 초기화 되는거구요
[쮸리아빠] [오전 11:12] 네
[가나다] [오전 11:25] 혹시 video = -1에서 -1로 초기화 하신 이유가 있으,신가요??
[쮸리아빠] [오전 11:27] 반복문에서 계속쓰이는 video 객체인데. 최초선언을 반복문내부에서 하면안되서 위로올렸고, 변수이름만 담아 두는거라 -1로 초기화하든 video='none'으로 초기화하든 상관없습니다.
[가나다] [오전 11:28] 삭제된 메시지입니다.
[가나다] [오전 11:29] if(record_flag==True and video==-1): # 녹화설정 On, videowriter 객체 미 초기화 시에만(최초 파일생성)
            save_record_path = base_path + previewName + '_' + str(now) + ".avi"
            print(save_record_path)
            video = cv2.VideoWriter(save_record_path, fourcc, 20.0,
                                    (frame.shape[1], frame.shape[0]))
[가나다] [오전 11:29] 그래서 여기서 video의 객체를 저장하고
[가나다] [오전 11:29] if record_flag == True :
            print("Recording...")
            if video!=-1:
                video.write(frame)
[가나다] [오전 11:29] video가 -1이 아닐때 저장하는궁뇨
[가나다] [오전 11:31] 그리고 어제 우려하신 부분이 now = datetime.datetime.now().strftime("%d_%H-%M-%S") 이게 write name에 들어가면 계속 다른 파일로 저장될수있다고 하셨잖아요?? 근데 이건 어제 제가 말씀드린 대로 마지막 시간으로 저장이 되는데 맞는거죠??
[쮸리아빠] [오전 11:37] 네, 비디오라이터는 처음한번만 생성하니까 마지막시간으로 저장됩니다
[가나다] [오전 11:45] 이게 동시에 녹화는 되는데 동시에 저장은 안되네요
[가나다] [오전 11:45] 우선 video를 cam 수만큼 늘려서 해보고 있긴한데
[가나다] [오전 11:45] 잘안되네요
[가나다] [오전 11:45] """
4. r키 입력시 record 변수만 true로 바꾸고, videowriter 초기화 로직 추가

5. waitkey(20) → waitkey(1)로 변경
  멀티스레딩이고, 카메라 3대면 속도가 느려서 바꿔봤습니다. PC 성능에 맞게 설정하면 됩니다.
"""

import datetime
import cv2
import threading
import os

base_path = os.path.dirname(os.path.abspath("__file__"))
base_path = base_path+"\\video"
if not os.path.exists(base_path):
    os.makedirs(base_path)

fourcc = cv2.VideoWriter_fourcc(*'XVID')
record = False

class camThread(threading.Thread):
    def __init__(self, previewName, camID):
       ...
[가나다] [오전 11:46] video 3개로 해서 마지막에 e 눌렀을때 release() 동시에 되도록 했는데 이게 안되네용
[가나다] [오전 11:46] video.release()를해야 최종 비디오 파일이 저장되는거죠??
[쮸리아빠] [오전 11:47] 네.. 위에 올려드린코드가 r 누르고 e 누르면 다 저장되도록 되있는데...
[쮸리아빠] [오전 11:48] 한번 차근차근보면서 작성해보세요. 직접 고민해보면서 해야 늘어요
[가나다] [오전 11:49] 네네 감사합니다
[가나다] [오전 11:49] 저렇게 3개로 하니까
[가나다] [오전 11:49] loop끝나고
[가나다] [오전 11:49] def camPreview(previewName, camID):
[가나다] [오전 11:50] 메서드로 들어오는 cam의 id가 loop 마다 다르네요
[가나다] [오전 11:57] 사진
[가나다] [오전 11:58] 동일하게 e key를 눌렀을때 release() 하지말고 if문 밖에서 하니까 동시에 저장이 되네요











[들보] [오후 4:23] 파이썬 뿐만 아니라 모든 프로세스는 단일 스레드로 시작되구요
[들보] [오후 4:23] OS에 따라 다르지만 프로세스 = 스레드 동일 레벨로 간주되는 극악의 경우도 있습니다.
[들보] [오후 4:24] CPU에선 코어 1개당 한 번 에 한 개의 스레드에 한 개의 라인만 실행을 시키는데, 싱글코어면 한 번에 한 프로세스의 한 스레드만 실행 가능한거죠
[들보] [오후 4:24] 코어 하나에 스레드 두개씩 있는 애들은 두 스레드씩 실행 가능하구요.
[들보] [오후 4:25] 그리고 파이썬의 스레딩 API 뿐만 아니라 모든 언어의 스레드라는 개념은 메인 스레드와 별개로 CPU한테 얘한테는 메인스레드랑 순차적으로 할당해서 읽지 말고 메인스레드랑 동등한 수준으로 두고 와리가리 치면서 실행해 달라고 요청하는거고
[들보] [오후 4:25] 스레드를 안나누면 그냥 순서대로만 실행하는 거구요
[들보] [오후 4:26] 멀티캠 레코딩에서는 모든 카메라가 동시에 데이터를 쏘고 있기 때문에 최소 카메라 대수만큼 스레드가 있어야 카메라마다 데이터를 받을 수 있는데 여기서 동기/비동기가 나뉘구요
[들보] [오후 4:26] 동기는 내가 데이터를 받았다고 OK 사인을 줘야만 다음 데이터를 갖고 올 수 있는건데
[들보] [오후 4:26] 카메라는 비동기라서 내가 OK를 하건 말건 계속 비디오프레임을 막 쏴줍니다
[들보] [오후 4:27] 그래서 제 때 못가져가면 프레임 몇개 날려먹는거죠. 그렇게 안 되려고 카메라마다 스레드 하나씩 붙여주는 겁니다. 그래도 CPU 코어 개수가 부족하면 결국 놓칠 확률이 증가하긴 한데 확률 상 놓칠 확률이 줄어들겠죠
[들보] [오후 4:28] 그리고 멀티캠레코딩을 구현하시는거라면 그랩 스레드(캠에서 받아오는거), 큐잉 및 관리 스레드(받은 이미지 리스트를 관리하고, 버퍼 큐가 안터지게 조정해주는 애들), 처리 스레드(이미지에서 탐지나 후처리 등 별개 처리를 수행하는 스레드), 저장 스레드(선별적으로 원하는 결과를 저장하거나 녹화처리)가 필요하구요
[들보] [오후 4:29] 본격적으로 녹화모듈을 만드시면 하드디스크에 파티션 하나 떼다가 녹화용 파일시스템을 별도로 구성하셔서 하드디스크 액세스로 인한 IO 딜레이를 최소화 시키셔야 합니다
[들보] [오후 4:29] 그럼 전 이제 다시 교육 들어가야 해서 중간에 끊습니다. @문정우  님이 자세하게 설명해 주실꺼에요 껄껄




